11월 1일
---

* broadcast-name 
	
	```bash
	# Makefile
	CONTIKI_PROJECT = broadcast-name
	all: $(CONTIKI_PROJECT)

	CONTIKI = ../..
	CONTIKI_WITH_RIME = 1			# for broadcast_open, ...
	include $(CONTIKI)/Makefile.include
	```
	
	```C
	// broadcast-name.c
	#include "contiki.h"
	#include "net/rime/rime.h"
	#include "random.h"

	#include <stdio.h>

	PROCESS(example_broadcast_process, "Broadcast example");		// process def
	AUTOSTART_PROCESSES(&example_broadcast_process);			// start process(es)

	static void broadcast_recv(struct broadcast_conn *c, const linkaddr_t *from)	// recieve callback
	{
		printf("broadcast message received from %d.%d: '%s'\n",
		from->u8[0], from->u8[1], (char *)packetbuf_dataptr());
	}


	static const struct broadcast_callbacks broadcast_call = {broadcast_recv};
	static struct broadcast_conn broadcast;


	PROCESS_THREAD(example_broadcast_process, ev, data)	// process thread for ex_broadcast_process
	{
	  static struct etimer et;					// event timer

	  PROCESS_EXITHANDLER(broadcast_close(&broadcast));		// set process exit handler

	  PROCESS_BEGIN();

	  broadcast_open(&broadcast, 129, &broadcast_call);		// open broadcast specifying conn,
	  								// register callback

	  while(1) {

		etimer_set(&et, CLOCK_SECOND * 4);			// delay 4 sec

		PROCESS_WAIT_EVENT_UNTIL(etimer_expired(&et));		// wait etimer to be expired

		packetbuf_copyfrom("Mookeun", 8);			// set packetbuf
		broadcast_send(&broadcast);				// broadcast
		printf("broadcast message sent\n");			// print log
	  }

	  PROCESS_END();
	}
	```

11월 3일
---
* blink

	```c
	#include "contiki.h"
	#include "sys/timer.h"
	#include "dev/leds.h"
	#include <stdio.h>

	PROCESS(blink_ex, "blink example");
	AUTOSTART_PROCESSES(&blink_ex);

	PROCESS_THREAD(blink_ex, ev, data){

	    PROCESS_EXITHANDLER(goto exit;)
	    PROCESS_BEGIN();

	    static struct etimer et;
	    while(1){
		printf("turning on all led\n");
		leds_on(LEDS_ALL);
		etimer_set(&et, CLOCK_SECOND);
		PROCESS_WAIT_EVENT_UNTIL(etimer_expired(&et));		// wait for a second

		printf("turning off all led\n");
		leds_off(LEDS_ALL);
		etimer_set(&et, CLOCK_SECOND);
		PROCESS_WAIT_EVENT_UNTIL(etimer_expired(&et));		// wait for a second
	    }


	exit:
	    leds_off(LEDS_ALL);
	    PROCESS_END();
	}
	```

11월 5일
---

* Process contexts
	* cooperative: sequential
	* preemptive: temporarily stop cooperative 
	* process -> cooperative 
	* interrupt, real time timers -> preemptive
	
* start on system boots & when module is loaded into system

* protothreads - way to structure code in a way that allows the system to run other activities when the code is waiting for something to happen.

	```c
	PROCESS_BEGIN(); // Declares the beginning of a process' protothread. 
	PROCESS_END(); // Declares the end of a process' protothread. 
	PROCESS_EXIT(); // Exit the process. 
	PROCESS_WAIT_EVENT(); // Wait for any event. 
	PROCESS_WAIT_EVENT_UNTIL(); // Wait for an event, but with a condition.
	PROCESS_YIELD(); // Wait for any event, equivalent to PROCESS_WAIT_EVENT().
	PROCESS_WAIT_UNTIL(); // Wait for a given condition; may not yield the process.
	PROCESS_PAUSE(); // Temporarily yield the process.
	```

* asynchronous event -> to event queue -> to receiver (by kernel)
	* delivered to the receiving process some time after they have been posted
	* if receiver is specific process, invoke the process
	* if receiver is all processes, sequentially deliver

* synchronous event -> directly deliver
	* only to specific process
	* functionally equivalent to a function call: the process to which the event is delivered is directly invoked, and the process that posted the event is blocked until the receiving process has finished processing the event.
	

